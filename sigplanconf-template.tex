%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}
% The following \documentclass options may be useful:
% preprint       Remove this option only once the paper is in final form.
%  9pt           Set paper in  9-point type (instead of default 10-point)
% 11pt           Set paper in 11-point type (instead of default 10-point).
% numbers        Produce numeric citations with natbib (instead of default author/year).
% authorversion  Prepare an author version, with appropriate copyright-space text.
\usepackage{amsmath}

\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}\reprintprice{\$15.00}
\copyrightdoi{nnnnnnn.nnnnnnn}

% For compatibility with auto-generated ACM eRights management
% instructions, the following alternate commands are also supported.
%\CopyrightYear{2016}
%\conferenceinfo{CONF'yy,}{Month d--d, 20yy, City, ST, Country}
%\isbn{978-1-nnnn-nnnn-n/yy/mm}\acmPrice{\$15.00}
%\doi{http://dx.doi.org/10.1145/nnnnnnn.nnnnnnn}

% Uncomment the publication rights used.
%\setcopyright{acmcopyright}
\setcopyright{acmlicensed}  % default
%\setcopyright{rightsretained}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Trinity: A Language for Multi-View Architecture Description and Control\titlenote{with optional title note}}
\subtitle{Subtitle Text, if any\titlenote{with optional subtitle note}}

\authorinfo{Name1\thanks{with optional author note}}
           {Affiliation1}
           {Email1}
\authorinfo{Name2 \and Name3\thanks{with optional author note}}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

% 2012 ACM Computing Classification System (CSS) concepts
% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010138.10010143</concept_id>
<concept_desc>Theory of computation~Program analysis</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Theory of computation~Program analysis}
% end generated code

% Legacy 1998 ACM Computing Classification System categories are also
% supported, but not recommended.
%\category{CR-number}{subcategory}{third-level}[fourth-level]
%\category{D.3.0}{Programming Languages}{General}
%\category{F.3.2}{Logics and Meanings of Programs}{Semantics of Programming Languages}[Program analysis]

\keywords
keyword1, keyword2

\section{Introduction}
	
	Understanding how a software system works is important in designing, implementing, and using it. Software architecture can be defined as the “fundamental organization of a system embodied in its components, their relations to each other, and the environment.” Any system, including a living organism can be understood from different perspectives and views; a human being can be analyzed in terms of his or her comprising systems as in the cardiovascular system or nervous system, or as a part of a larger structure, like a friendship, society, or species. 

	A single software system can similarly be interpreted as a composite whole or a part of a larger system.  The software architecture of a system, or its “fundamental organization … embodied in its components, their relationship to each other, and to the environment, and the principles guiding its design and evolution,” is comprised of three basic levels. Software is comprised of three general architecture views: Software can be understood as sets of implementation units and sets of runtime components that have behavior and interact with one another, as well as in terms of its interactions with non-software elements, like hardware. These views are concisely called the Module, Component-and-Connector, and Allocation views respectively. Understanding a software system in terms of code-implementation (how it works), runtime entities (how it interacts with itself), and non-software interactions (how it interacts with non-software parts of a system) is crucial for its initial design and implementation, later adaptation, and use. 
	
	While architecture is essential to developing, adapting, and understanding a software system, current software architecture practices provide few and weaker-than-desirable guarantees that architecture views reflect what happens when a system is in use. When a developer initially designs her software system, she might draw up a graph representing various components and their relationships. Whether the components are set of programmatic code pieces, runtime elements, or system parts depends on what stage of development and from what architecture view she is approaching the design. While the logical relationships between these theoretical elements are sound, their realization may present some issues. 
	
	For example, when designing a <SYSTEM>, one might draw up a graph representing the intended Component-and-Connector (CnC) view, including the components, or the <LIST OF COMPONENTS> and the connectors, or the <LIST OF CONNECTORS>. However a conflict between the <CONNECTOR TYPE> connector and the <COMPONENT> forces the developer to change the architecture during implementation. Depending on the effects of this change and others like it, the realization may not uphold the guarantees of the intended architecture. In the aforementioned example, the planned <CONNECTOR TYPE> connector ensured that the <COMPONENT> could only communicate with the <OTHER COMPONENT> in a specific way. While implementation adjustments were required for completion, the assumptions from the original architecture about how COMPONENT1 is able to communicate with other runtime components may no longer hold. Here, communication integrity is no longer guaranteed. 
	
	Software system designs must adapt as the problem or understanding of it changes. This type of adaptability is essential for building software, but it also makes verifying intended software guarantees, such as communication integrity, difficult. Understanding how a software system works in practice, as opposed to theoretically, is necessary when developing, adapting, and using it. 
	

\section{Early Design}

	As a solution to the issue of carrying intended architecture guarantees through to the final implementation, we present Trinity, an extension to the Wyvern programming language that aims to make software architecture views a presecriptive, rather than simply descriptive, aspect of a software system in Wyvern. Trinity incorporates architecture in a unique way, making it a “live” component: software systems can have hard-coded architectures for all three architecture views. Instead of providing a descriptive architecture that attempts to explain how a system functions, Trinity supports architecture as a language construct in Wyvern. In the case of the CnC architectural view, what would conventionally be only logical organizations and distinctions between components and connectors, can now be actually implemented components and connectors. Since Trinity supports prescriptive software architecture views it allows developers to catch architecture-related errors at compile time, rather than runtime. This novel ability enables safer inspection for vulnerabilities originating in architecture flaws. 

	Trinity is designed to safeguard communication integrity, which is a top priority in regards to desired guarantees to preserve in end-product implementations. To enforce communication integrity is to ensure that “each component in [an] implementation may [communicate] directly with … components to which it is connected in the architecture.” In our early implementation of Trinity, we have provided support for a “hard-coded” Component-and-Connector view of a Wyvern software system. Our design translates concepts from software architecture into implementation capabilities. 
	
	Entities in the Cnc architecture view are keywords/types/objects in Trinity. An entire software architecture, comprised of components and connectors, is contained within an architecture object/type/keyword. Trinity components are runtime components such as servers, clients, and databases. Ports are fields of a component that act as access points to interact with other components; these include interfaces that provide details about the interface another component must fulfill to communicate with said component through said port. Connectors, such as JDBC connectors, connect multiple ports of components. Attachments allow the programmer to “actually” connect components using ports of components and provided connectors. An entryPoint is an access point for a program using the specified architecture. It might be a function of a particular component in the architecture. For example, an architecture describing a three-tier web application might have an entryPoint specified by the “start()” function of a client component. Bindings allow the programmer to alias functions of components, to reduce code verbosity. 

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% The 'abbrvnat' bibliography style is recommended.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}
